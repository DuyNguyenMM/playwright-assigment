# Test info

- Name: Product Tests >> Verify that user can search existing product succeesfully
- Location: /home/runner/work/playwright-assigment/playwright-assigment/tests/product/product.spec.ts:45:9

# Error details

```
Error: locator.innerText: Test timeout of 30000ms exceeded.
Call log:
  - waiting for locator('.product-name')

    at ProductActions.getProductDetail (/home/runner/work/playwright-assigment/playwright-assigment/pages/product/actions.ts:37:76)
    at ProductPage.verifyThatProductInformationShouldBeLoadedSuccessfully (/home/runner/work/playwright-assigment/playwright-assigment/pages/product/page.ts:14:61)
    at /home/runner/work/playwright-assigment/playwright-assigment/tests/product/product.spec.ts:49:27
```

# Page snapshot

```yaml
- main:
  - heading "Icon for demo.nopcommerce.comdemo.nopcommerce.com" [level=1]:
    - img "Icon for demo.nopcommerce.com"
    - text: demo.nopcommerce.com
  - paragraph: Verify you are human by completing the action below.
  - text: demo.nopcommerce.com needs to review the security of your connection before proceeding.
- contentinfo:
  - text: "Ray ID:"
  - code: 9a2937ba9aa4fa15
  - text: Performance & security by
  - link "Cloudflare":
    - /url: https://www.cloudflare.com?utm_source=challenge&utm_campaign=m
```

# Test source

```ts
   1 | import { expect, Page } from "@playwright/test";
   2 | import { locators } from "./locators";
   3 | import { ItemName } from "./schema";
   4 | import { getNumberInString } from "@/utils/string-handler";
   5 | import { error } from "console";
   6 |
   7 | export class ProductActions {
   8 |     readonly page: Page;
   9 |     constructor(page: Page) {
   10 |         this.page = page;
   11 |     }
   12 |
   13 |     async sortOptionMapping(sortOption: string) {
   14 |         switch (sortOption) {
   15 |             case 'Position':
   16 |                 return '0';
   17 |             case 'Name: A to Z':
   18 |                 return '5';
   19 |             case 'Name: Z to A':
   20 |                 return '6'
   21 |             case 'Price: Low to High':
   22 |                 return '10'
   23 |             case 'Price: High to Low':
   24 |                 return '11'
   25 |             case 'Created on':
   26 |                 return '15'
   27 |             default:
   28 |                 throw new Error(`${sortOption} are not correct. Try again with correct one`)
   29 |         }
   30 |     }
   31 |
   32 |     async getProductDetail(item: string[] = ['productNameLabel', 'productShortDescriptionLabel', 'productPriceLabel', 'productAdditionalDetailLabel', 'productDeliveryLabel', 'productMinQuantityLabel']): Promise<Record<string, string>[]> {
   33 |         const result: Record<string, string>[] = [];
   34 |         const detailProduct: Record<string, string> = {}
   35 |         for (const i of item) {
   36 |             if (Object.keys(locators).includes(i)) {
>  37 |                 const text = await this.page.locator((locators as any)[i]).innerText();
      |                                                                            ^ Error: locator.innerText: Test timeout of 30000ms exceeded.
   38 |                 detailProduct[i.replace('Label', '')] = text;
   39 |             } else {
   40 |                 throw new Error(`Item ${i} is not defined in locators`);
   41 |             }
   42 |         }
   43 |         result.push(detailProduct);
   44 |         return result;
   45 |     };
   46 |
   47 |     async selectSortOption(sortOption: string) {
   48 |         await this.page.locator(locators.sortByDropdownList).selectOption({ value: await this.sortOptionMapping(sortOption) });
   49 |     }
   50 |
   51 |     async getLoadProductStatus(): Promise<string> {
   52 |         let status = 'loading';
   53 |         const loadingProduct = await this.page.locator(locators.loadingProductAnimation).getAttribute("style");
   54 |         if (loadingProduct === 'display: none;') {
   55 |             status = 'loaded';
   56 |         }
   57 |         return status;
   58 |     }
   59 |
   60 |     async waitForProductLoaded(timeout: number = 10000): Promise<void> {
   61 |         const startTime = Date.now();
   62 |
   63 |         while (true) {
   64 |             const status = await this.getLoadProductStatus();
   65 |
   66 |             if (status === 'loaded') {
   67 |                 return;
   68 |             }
   69 |
   70 |             if (Date.now() - startTime >= timeout) {
   71 |                 throw new Error(`Product is still loading after ${timeout}ms`);
   72 |             }
   73 |
   74 |             await this.page.waitForTimeout(200);
   75 |         }
   76 |     }
   77 |
   78 |     async getListProduct(): Promise<Record<string, string>[]> {
   79 |         const listProduct: Record<string, string>[] = []
   80 |         const products = await this.page.locator(locators.productListView).locator(locators.productItem).all();
   81 |         for (const product of products) {
   82 |             const detail: Record<string, string> = {};
   83 |             let rating = '';
   84 |             const rawRating = await product.locator(locators.productRating).getAttribute("style");
   85 |             if (rawRating) {
   86 |                 const n = getNumberInString(rawRating)[0] / 20;
   87 |                 if (n < 1 || n > 5) {
   88 |                     throw new Error(` Rating value: ${rawRating} is invalid.`)
   89 |                 }
   90 |                 rating = n.toString();
   91 |             }
   92 |             detail.title = await product.locator(locators.productTitle).innerText();
   93 |             detail.rating = rating;
   94 |             detail.price = await product.locator(locators.productPrice).innerText();
   95 |             listProduct.push(detail);
   96 |         }
   97 |         return listProduct
   98 |     }
   99 |
  100 |     async verifyProductPriceIsSortByDownToHigh(listProduct: Record<string, string>[]){
  101 |         for (let i = 0; i < listProduct.length; i++) {
  102 |             if (listProduct[i] > listProduct[i+1]){
  103 |                 throw new Error('List product is not arrange by price low to high')
  104 |             }
  105 |         }
  106 |     }
  107 | }
```